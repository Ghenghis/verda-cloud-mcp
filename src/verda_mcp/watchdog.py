"""Windsurf WatchDog - Automatic Training Monitor for Verda MCP.

When enabled, monitors training progress every 10-15 minutes and creates
timestamped markdown reports automatically.
"""

import asyncio
import logging
import os
from datetime import datetime
from pathlib import Path
from typing import Optional
import json

logger = logging.getLogger(__name__)

# WatchDog state
_watchdog_enabled = False
_watchdog_task: Optional[asyncio.Task] = None
_watchdog_instance_ip: Optional[str] = None
_watchdog_interval_minutes = 10
_reports_dir: Path = Path.home() / "verda_watchdog_reports"


class WatchDogReport:
    """Generates timestamped monitoring reports."""
    
    def __init__(self, reports_dir: Path):
        self.reports_dir = reports_dir
        self.reports_dir.mkdir(parents=True, exist_ok=True)
    
    def get_timestamp(self) -> str:
        """Get current timestamp for reports."""
        return datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    
    def get_display_time(self) -> str:
        """Get human-readable timestamp."""
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    def create_report(
        self,
        instance_ip: str,
        gpu_status: str,
        training_running: bool,
        recent_logs: str,
        disk_space: str,
        memory_usage: str,
        extra_info: Optional[dict] = None,
    ) -> Path:
        """Create a timestamped markdown report."""
        timestamp = self.get_timestamp()
        display_time = self.get_display_time()
        
        report_name = f"watchdog_report_{timestamp}.md"
        report_path = self.reports_dir / report_name
        
        # Build report content
        content = [
            f"# ğŸ• WatchDog Report",
            f"**Generated**: {display_time}",
            f"**Instance IP**: {instance_ip}",
            f"**Training Status**: {'âœ… RUNNING' if training_running else 'âŒ NOT RUNNING'}",
            "",
            "---",
            "",
            "## ğŸ–¥ï¸ GPU Status",
            "```",
            gpu_status[:3000] if gpu_status else "Unable to retrieve",
            "```",
            "",
            "## ğŸ“Š Recent Training Logs",
            "```",
            recent_logs[:5000] if recent_logs else "No logs available",
            "```",
            "",
            "## ğŸ’¾ Disk Space",
            "```",
            disk_space if disk_space else "Unable to retrieve",
            "```",
            "",
            "## ğŸ§  Memory Usage",
            "```",
            memory_usage if memory_usage else "Unable to retrieve",
            "```",
        ]
        
        if extra_info:
            content.append("")
            content.append("## ğŸ“‹ Additional Info")
            content.append("```json")
            content.append(json.dumps(extra_info, indent=2))
            content.append("```")
        
        content.append("")
        content.append("---")
        content.append(f"*Report generated by Windsurf WatchDog at {display_time}*")
        
        # Write report
        report_path.write_text("\n".join(content), encoding='utf-8')
        logger.info(f"WatchDog report created: {report_path}")
        
        return report_path
    
    def create_summary_report(self) -> Path:
        """Create a summary of all reports."""
        reports = sorted(self.reports_dir.glob("watchdog_report_*.md"))
        
        summary_path = self.reports_dir / "WATCHDOG_SUMMARY.md"
        
        content = [
            "# ğŸ• WatchDog Report Summary",
            f"**Generated**: {self.get_display_time()}",
            f"**Total Reports**: {len(reports)}",
            "",
            "---",
            "",
            "## Report History",
            "",
        ]
        
        for report in reports[-20:]:  # Last 20 reports
            timestamp = report.stem.replace("watchdog_report_", "")
            content.append(f"- [{timestamp}]({report.name})")
        
        summary_path.write_text("\n".join(content), encoding='utf-8')
        return summary_path
    
    def get_latest_report(self) -> Optional[Path]:
        """Get the most recent report."""
        reports = sorted(self.reports_dir.glob("watchdog_report_*.md"))
        return reports[-1] if reports else None


# Global reporter instance
_reporter: Optional[WatchDogReport] = None


def get_reporter() -> WatchDogReport:
    """Get the global report generator."""
    global _reporter
    if _reporter is None:
        _reporter = WatchDogReport(_reports_dir)
    return _reporter


async def _do_watchdog_check(instance_ip: str) -> dict:
    """Perform a single watchdog check."""
    from .ssh_tools import get_ssh_manager
    
    manager = get_ssh_manager()
    loop = asyncio.get_event_loop()
    
    results = {
        "timestamp": datetime.now().isoformat(),
        "instance_ip": instance_ip,
        "gpu_status": "",
        "training_running": False,
        "recent_logs": "",
        "disk_space": "",
        "memory_usage": "",
    }
    
    try:
        # GPU status
        results["gpu_status"] = await loop.run_in_executor(
            None, lambda: manager.get_gpu_status(instance_ip)
        )
    except Exception as e:
        results["gpu_status"] = f"Error: {e}"
    
    try:
        # Check if training is running
        stdout, _, _ = await loop.run_in_executor(
            None, lambda: manager.run_command(instance_ip, "ps aux | grep -E 'python.*train' | grep -v grep")
        )
        results["training_running"] = bool(stdout.strip())
    except Exception as e:
        logger.warning(f"Error checking training status: {e}")
    
    try:
        # Recent logs
        results["recent_logs"] = await loop.run_in_executor(
            None, lambda: manager.get_training_logs(instance_ip, lines=50)
        )
    except Exception as e:
        results["recent_logs"] = f"Error: {e}"
    
    try:
        # Disk space
        stdout, _, _ = await loop.run_in_executor(
            None, lambda: manager.run_command(instance_ip, "df -h /workspace")
        )
        results["disk_space"] = stdout
    except Exception as e:
        results["disk_space"] = f"Error: {e}"
    
    try:
        # Memory usage
        stdout, _, _ = await loop.run_in_executor(
            None, lambda: manager.run_command(instance_ip, "free -h")
        )
        results["memory_usage"] = stdout
    except Exception as e:
        results["memory_usage"] = f"Error: {e}"
    
    return results


async def _watchdog_loop(instance_ip: str, interval_minutes: int):
    """Main watchdog monitoring loop."""
    global _watchdog_enabled
    
    reporter = get_reporter()
    logger.info(f"WatchDog started for {instance_ip}, checking every {interval_minutes} minutes")
    
    while _watchdog_enabled:
        try:
            # Perform check
            results = await _do_watchdog_check(instance_ip)
            
            # Create report
            report_path = reporter.create_report(
                instance_ip=results["instance_ip"],
                gpu_status=results["gpu_status"],
                training_running=results["training_running"],
                recent_logs=results["recent_logs"],
                disk_space=results["disk_space"],
                memory_usage=results["memory_usage"],
            )
            
            logger.info(f"WatchDog check complete: {report_path}")
            
            # Alert if training stopped
            if not results["training_running"]:
                logger.warning("âš ï¸ WatchDog Alert: Training is NOT running!")
            
        except Exception as e:
            logger.error(f"WatchDog check failed: {e}")
        
        # Wait for next check
        await asyncio.sleep(interval_minutes * 60)
    
    logger.info("WatchDog stopped")


async def start_watchdog(instance_ip: str, interval_minutes: int = 10) -> str:
    """Start the WatchDog monitoring service.
    
    Args:
        instance_ip: IP address of the instance to monitor.
        interval_minutes: Check interval in minutes (default: 10).
    
    Returns:
        Status message.
    """
    global _watchdog_enabled, _watchdog_task, _watchdog_instance_ip, _watchdog_interval_minutes
    
    if _watchdog_enabled:
        return f"WatchDog is already running for {_watchdog_instance_ip}"
    
    _watchdog_enabled = True
    _watchdog_instance_ip = instance_ip
    _watchdog_interval_minutes = interval_minutes
    
    # Start the monitoring loop
    _watchdog_task = asyncio.create_task(_watchdog_loop(instance_ip, interval_minutes))
    
    reporter = get_reporter()
    
    return f"""# ğŸ• WatchDog ENABLED

**Monitoring**: {instance_ip}
**Interval**: Every {interval_minutes} minutes
**Reports Directory**: {reporter.reports_dir}

WatchDog will automatically:
- Check GPU status (nvidia-smi)
- Monitor training process
- Capture recent logs
- Track disk space and memory
- Create timestamped markdown reports

To disable: Use `watchdog_disable` tool"""


async def stop_watchdog() -> str:
    """Stop the WatchDog monitoring service.
    
    Returns:
        Status message.
    """
    global _watchdog_enabled, _watchdog_task, _watchdog_instance_ip
    
    if not _watchdog_enabled:
        return "WatchDog is not running"
    
    _watchdog_enabled = False
    
    if _watchdog_task:
        _watchdog_task.cancel()
        try:
            await _watchdog_task
        except asyncio.CancelledError:
            pass
        _watchdog_task = None
    
    # Create final summary
    reporter = get_reporter()
    summary_path = reporter.create_summary_report()
    
    result = f"""# ğŸ• WatchDog DISABLED

**Was monitoring**: {_watchdog_instance_ip}
**Summary report**: {summary_path}
**All reports in**: {reporter.reports_dir}"""
    
    _watchdog_instance_ip = None
    
    return result


async def get_watchdog_status() -> str:
    """Get current WatchDog status.
    
    Returns:
        Status information.
    """
    reporter = get_reporter()
    latest = reporter.get_latest_report()
    
    if _watchdog_enabled:
        return f"""# ğŸ• WatchDog Status: ENABLED

**Monitoring**: {_watchdog_instance_ip}
**Interval**: Every {_watchdog_interval_minutes} minutes
**Reports Directory**: {reporter.reports_dir}
**Latest Report**: {latest.name if latest else 'None yet'}"""
    else:
        return f"""# ğŸ• WatchDog Status: DISABLED

**Reports Directory**: {reporter.reports_dir}
**Latest Report**: {latest.name if latest else 'None'}

Use `watchdog_enable` to start monitoring."""


async def get_latest_watchdog_report() -> str:
    """Get the content of the latest WatchDog report.
    
    Returns:
        Report content or status message.
    """
    reporter = get_reporter()
    latest = reporter.get_latest_report()
    
    if not latest:
        return "No WatchDog reports found. Enable WatchDog to start monitoring."
    
    return latest.read_text(encoding='utf-8')


async def manual_watchdog_check(instance_ip: str) -> str:
    """Perform a manual WatchDog check (without enabling continuous monitoring).
    
    Args:
        instance_ip: IP address of the instance to check.
    
    Returns:
        Check results and report path.
    """
    results = await _do_watchdog_check(instance_ip)
    
    reporter = get_reporter()
    report_path = reporter.create_report(
        instance_ip=results["instance_ip"],
        gpu_status=results["gpu_status"],
        training_running=results["training_running"],
        recent_logs=results["recent_logs"],
        disk_space=results["disk_space"],
        memory_usage=results["memory_usage"],
    )
    
    status = "âœ… RUNNING" if results["training_running"] else "âŒ NOT RUNNING"
    
    return f"""# ğŸ• Manual WatchDog Check Complete

**Instance**: {instance_ip}
**Training Status**: {status}
**Report Saved**: {report_path}

## Quick Summary
{results["gpu_status"][:1000]}

## Recent Logs
```
{results["recent_logs"][:2000]}
```"""
